<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #map-container {
            width: 50%;
            height: 100%;
            border: 1px solid #ccc;
            position: sticky;
            top: 0;
        }

        /* Set the size of the div element that contains the map */
        #map {
            height: 100%;
            /* The height is the full height of the container */
            width: 100%;
            /* The width is the full width of the container */
        }

        .left {
            width: 50%;
            padding: 20px;
            background-color: #f5f5f5;
            border-right: 1px solid #ccc;
            overflow-y: auto;
            max-height: 100vh;
        }

        .left h2 {
            margin-top: 0;
        }

        form {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="text"],
        select {
            width: 100%;
            padding: 5px;
            margin-bottom: 10px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        input[type="button"] {
            padding: 8px 16px;
            background-color: #4caf50;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 10px;
            /* Add margin-bottom to create space */
        }

        input[type="button"]:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #rectangle-coordinates,
        #rectangle-perimeter {
            margin-top: 20px;
        }

        #points-container {
            margin-top: 20px;
        }

        #points {
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 3px;
            max-height: 200px;
            overflow-y: auto;
        }

        #export-points,
        #export-path {
            margin-top: 10px;
            /* Add margin-top to separate from other buttons */
        }

        #toggle-lines {
            padding: 8px 16px;
            background-color: #ff0000;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 10px;
        }

        #toggle-lines:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #hide-markers {
            padding: 8px 16px;
            background-color: #ff0000;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 10px;
        }

        #hide-markers:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .form-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .form-group label {
            margin-right: 10px;
        }

        .form-group .input-field {
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <div id="container">
        <div class="left">
            <h2>Teleport To:</h2>
            <form id="teleport-form">
                <label for="latitude">Latitude:</label>
                <input type="text" id="latitude" name="latitude">
                <label for="longitude">Longitude:</label>
                <input type="text" id="longitude" name="longitude">
                <label for="location-select">Or select a location:</label>
                <select id="location-select">
                    <option value="">--Select a Location--</option>
                    <option value="11.993775, 1.413218">Boungo Mine - Burkina Faso</option>
                    <option value="6.8748500171393445, -8.10307329891968">Ity Mine - Ivory Coast</option>
                    <option value="12.000584, -3.412255">Mana Mine - Burkina Faso</option>
                </select>
                <input type="button" value="Go" onclick="teleport()">
                <div class="form-group">
                    <label for="grid-size">Grid Size:</label>
                    <input type="number" id="grid-size" name="grid-size" min="1" class="input-field">

                    <label for="num-points">Random Points:</label>
                    <input type="number" id="num-points" name="Random Points" min="4" value="" class="input-field">

                    <label for="capacity-input">ROMIE Capacity:</label>
                    <input type="number" id="capacity-input" name="ROMIE Capacity" min="1" value="1000"
                        class="input-field">
                </div>

                <br>

                <input type="button" id="start" value="Start Demarcate" onclick="startDrawing()">
                <input type="button" id="stop" value="Stop Demarcate" onclick="stopDrawing()" disabled>
                <input type="button" id="reset" value="Reset" onclick="resetDrawing()" disabled>
                <input type="button" id="resize" value="Resize" onclick="resizeMap()" disabled>
                <input type="button" id="choose-points" value="Choose Points" onclick="choosePoints()" disabled>
                <input type="button" id="create-grid" value="Create Grid" onclick="createGrid()" disabled>
                <input type="button" id="solve-tsp" value="Solve TSP" disabled>
                <br>
                <input type="button" id="export-points" value="Export Points" onclick="exportPoints()" disabled>
                <input type="button" id="export-path" value="Export Path" onclick="exportPath()" disabled>
                <input type="button" id="export-path-gazebo" value="Export Path Gazebo" onclick="exportPathGazebo()"
                    disabled>
                <select id="predefined-data-select">
                    <option value="tsp20">TSP20</option>
                    <option value="tsp50">TSP50</option>
                    <option value="tsp100">TSP100</option>
                    <option value="tsp200">TSP200</option>
                    <option value="tsp500">TSP500</option>
                </select>

                <input type="button" id="own-data" value="Use Own Data" onclick="ownData()">


                <button id="toggle-lines">Hide Lines</button>
                <button id="hide-markers">Hide Markers</button>


                <!-- change this line and the function-->
            </form>
            <h2>Rectangle coordinates:</h2>
            <div id="rectangle-coordinates"></div>
            <div>
                <h2>Rectangle Area:</h2>
                <div id="rectangle-perimeter"></div>
            </div>
            <div id="points-container">
                <h2>Points:</h2>
                <div id="points"></div>
            </div>
            <div id="points-container">
                <h2>Optimal route: </h2>
                <div id="progress-bar"></div>
                <div id="optimal-route"></div>
            </div>
            <div id="points-container">
                <h2>Optimal cost: </h2>
                <div id="optimal-cost"></div>
            </div>
            <div id="points-container">
                <h2>Job to be done in: </h2>
                <div id="optimal-time"></div>
            </div>
            <div id="points-container">
                <h2>Max battery reserve distance:</h2>
                <div id="max-reserve-distance"></div>
            </div>




        </div>

        <div id="map-container">
            <div id="map"></div>
        </div>

    </div>

    <!-- Include the ProgressBar.js library -->
    <script src="https://cdn.jsdelivr.net/npm/progressbar.js/dist/progressbar.min.js"></script>

    <script>

        let map, marker, rectangle, boundaries, drawingManager, infoWindow;
        let points = [];
        let gridLines = [];
        let optimalRoute = [];
        let tracingMode = false;
        let linePaths = [];
        let linesVisible = true;
        let markersVisible = true;
        let oocMarkers = [];
        let cslMarkers = [];
        let pathWithChargingStations = [];

        let progressBar;
        let progress = 0;


        // TestBench Creation
        let predefinedLocations = {
            tsp20: [
                { lat: 44.5474520356833, lng: -78.5374334275837 },
                { lat: 44.5551912555326, lng: -78.544627425933 },
                { lat: 44.5380884153786, lng: -78.5484025914099 },
                { lat: 44.5451546021788, lng: -78.5360838236916 },
                { lat: 44.5367714555196, lng: -78.5414448634013 },
                { lat: 44.5393103020037, lng: -78.5320729714972 },
                { lat: 44.5380895590729, lng: -78.5328601918095 },
                { lat: 44.5541025845604, lng: -78.5301444211056 },
                { lat: 44.5464320494035, lng: -78.545840468605 },
                { lat: 44.5401710749569, lng: -78.5359506767182 },
                { lat: 44.5415150815918, lng: -78.5346904566408 },
                { lat: 44.5488794941345, lng: -78.5430521704597 },
                { lat: 44.5430032685835, lng: -78.5329913415683 },
                { lat: 44.5440688118581, lng: -78.5306626062108 },
                { lat: 44.5551865408976, lng: -78.5477346048269 }
            ],
            tsp50: [
                { lat: 44.5474520356833, lng: -78.5374334275837 },


            ],

            tsp100: [

            ],

            tsp200: [

            ],

            tsp500: [

            ],

        };


        function ownData() {
            // Get the selected data set
            let selectedDataSet = document.getElementById('predefined-data-select').value;

            // Clear existing points if any
            points.forEach((point) => point.setMap(null));
            points = [];

            // Place markers at predefined locations
            predefinedLocations[selectedDataSet].forEach((location, index) => {
                const point = new google.maps.Marker({
                    position: { lat: location.lat, lng: location.lng },
                    map: map,
                    label: `${index + 1}`,
                    id: index + 1
                });

                points.push(point);

                // Update the points display
                document.getElementById('points').innerHTML += 'Point ' + (points.length) + ': ' + point.position.toString() + '<br>';
            });

            // Enable the "Solve TSP" button
            document.getElementById('solve-tsp').disabled = false;
        }


        const toggleLinesButton = document.getElementById('toggle-lines');

        // Add event listener to handle button click
        toggleLinesButton.addEventListener('click', function (event) {
            event.preventDefault(); // Prevent form submission

            // Toggle the visibility of the lines
            if (linesVisible) {
                // Lines are currently visible, hide them
                hideLines();
                toggleLinesButton.textContent = 'Reactivate Lines';
            } else {
                // Lines are currently hidden, reactivate them
                reactivateLines();
                toggleLinesButton.textContent = 'Hide Lines';
            }

            // Toggle the linesVisible variable
            linesVisible = !linesVisible;
        });

        // Function to hide the lines
        function hideLines() {
            linePaths.forEach(function (linePath) {
                linePath.setMap(null);
            });
        }

        // Function to reactivate the lines
        function reactivateLines() {
            linePaths.forEach(function (linePath) {
                linePath.setMap(map);
            });
        }

        const hideMarkersButton = document.getElementById('hide-markers');

        // Add event listener to handle button click
        hideMarkersButton.addEventListener('click', function (event) {
            event.preventDefault(); // Prevent form submission

            // Toggle the visibility of the markers
            if (markersVisible) {
                // Markers are currently visible, hide them
                hideMarkers();
                hideMarkersButton.textContent = 'Reactivate Markers';
            } else {
                // Markers are currently hidden, reactivate them
                reactivateMarkers();
                hideMarkersButton.textContent = 'Hide Markers';
            }

            // Toggle the markersVisible variable
            markersVisible = !markersVisible;
        });

        // Function to hide the markers
        function hideMarkers() {
            oocMarkers.forEach(function (marker) {
                marker.setMap(null);
            });
            cslMarkers.forEach(function (marker) {
                marker.setMap(null);
            });
        }

        // Function to reactivate the markers
        function reactivateMarkers() {
            oocMarkers.forEach(function (marker) {
                marker.setMap(map);
            });
            cslMarkers.forEach(function (marker) {
                marker.setMap(map);
            });
        }

        // Initialize the map
        function initMap() {
            const yourPlace = { lat: 44.5452, lng: -78.5389 };
            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 4,
                center: yourPlace,
                mapTypeId: 'satellite', // Can be any valid type
                scaleControl: true // Adds a scale control
            });
            marker = new google.maps.Marker({ position: yourPlace, map: map });
        }

        // Teleport the map to a given latitude and longitude
        function teleport() {
            const latInput = document.getElementById('latitude').value;
            const lngInput = document.getElementById('longitude').value;
            let position;

            if (latInput && lngInput) {
                position = { lat: parseFloat(latInput), lng: parseFloat(lngInput) };
            } else {
                const selectedLocation = document.getElementById('location-select').value.split(',');
                if (selectedLocation.length === 2) {
                    position = { lat: parseFloat(selectedLocation[0]), lng: parseFloat(selectedLocation[1]) };
                }
            }

            if (position) {
                map.setCenter(position);
                marker.setPosition(position);
            }
        }

        function createGrid() {
            const gridSize = document.getElementById('grid-size').value;
            const bounds = rectangle.getBounds();

            // Disable the "Create Grid" button
            document.getElementById('create-grid').disabled = true;

            // Calculate lat and lng increments based on the size of the grid
            const latIncrement = (bounds.getNorthEast().lat() - bounds.getSouthWest().lat()) / gridSize;
            const lngIncrement = (bounds.getNorthEast().lng() - bounds.getSouthWest().lng()) / gridSize;

            let counter = 1;

            // Place markers on each intersection
            for (let i = 0; i <= gridSize; i++) {
                for (let j = 0; j <= gridSize; j++) {
                    const lat = bounds.getSouthWest().lat() + latIncrement * i;
                    const lng = bounds.getSouthWest().lng() + lngIncrement * j;
                    const point = new google.maps.Marker({
                        position: { lat: lat, lng: lng },
                        map: map,
                        label: `${counter}`
                    });

                    console.log(point);

                    points.push(point);

                    // Update the points display
                    document.getElementById('points').innerHTML += 'Point ' + (points.length) + ': ' + point.position.toString() + '<br>';

                    counter++;
                }
            }

            // Draw grid lines
            for (let i = 0; i <= gridSize; i++) {
                const lat = bounds.getSouthWest().lat() + latIncrement * i;
                const lng = bounds.getSouthWest().lng() + lngIncrement * i;

                // horizontal grid line
                const horizontalLine = new google.maps.Polyline({
                    path: [
                        { lat: lat, lng: bounds.getSouthWest().lng() },
                        { lat: lat, lng: bounds.getNorthEast().lng() }
                    ],
                    strokeColor: '#FF0000',
                    strokeOpacity: 1.0,
                    strokeWeight: 2,
                    map: map
                });

                // vertical grid line
                const verticalLine = new google.maps.Polyline({
                    path: [
                        { lat: bounds.getSouthWest().lat(), lng: lng },
                        { lat: bounds.getNorthEast().lat(), lng: lng }
                    ],
                    strokeColor: '#FF0000',
                    strokeOpacity: 1.0,
                    strokeWeight: 2,
                    map: map
                });

                gridLines.push(horizontalLine, verticalLine);
            }
        }

        // Place the points in the rectangle on the map
        function placePoint(event) {
            const bounds = rectangle.getBounds();

            if (bounds.contains(event.latLng)) {
                const point = new google.maps.Marker({
                    position: event.latLng,
                    map: map,
                    label: `${points.length + 1}`,
                    id: points.length + 1
                });

                points.push(point);

                // Update the points display
                document.getElementById('points').innerHTML += 'Point ' + (points.length) + ': ' + event.latLng.toString() + '<br>';
            } else {
                alert('Point is out of bounds');
            }
        }

        function stopChoosingPoints() {
            google.maps.event.clearListeners(map, 'click');
            document.getElementById('choose-points').disabled = false;
        }

        function choosePoints() {
            // Add a click listener to the map
            map.addListener('click', placePoint);

            // Disable the Choose Points button
            document.getElementById('choose-points').disabled = true;
        }

        function startDrawing() {
            map.setOptions({ disableDefaultUI: true, draggable: true });

            // Calculate bounds around the current center of the map
            let center = map.getCenter();
            const bounds = {
                north: center.lat() + 0.015,
                south: center.lat() - 0.015,
                east: center.lng() + 0.015,
                west: center.lng() - 0.015
            };

            // Create a rectangle and add it to the map
            rectangle = new google.maps.Rectangle({
                bounds: bounds,
                editable: true,
                draggable: true
            });
            rectangle.setMap(map);

            // Add an event listener to update the coordinate display as the rectangle is moved or resized
            rectangle.addListener('bounds_changed', showNewRect);

            // Call the calculateArea function to update the perimeter display
            rectangle.addListener('bounds_changed', calculateArea);

            // Add a click listener to the map
            map.addListener('click', placePoint);


            document.getElementById('start').disabled = true;
            document.getElementById('stop').disabled = false;
            document.getElementById('reset').disabled = false; // Enable the Reset button
            document.getElementById('resize').disabled = false; // Disable the Resize button
            document.getElementById('choose-points').disabled = true; // Disable the Choose Points button
            document.getElementById('solve-tsp').disabled = true; // Disable the Solve TSP button
            document.getElementById('export-points').disabled = true; // Disable the export button
            document.getElementById('export-path').disabled = true; // Disable the export button
            document.getElementById('export-path-gazebo').disabled = true; // Disable the export button
            document.getElementById('own-data').disabled = false; // Disable the own data button


        }

        function stopDrawing() {
            rectangle.setOptions({ disableDefaultUI: false, draggable: false, editable: false });
            map.setOptions({ disableDefaultUI: false, draggable: false, draggableCursor: '' });

            // Do not clear the map click event listener here. It's now handled by stopChoosingPoints()
            google.maps.event.clearListeners(rectangle, 'bounds_changed');

            // Add a click listener to the map
            rectangle.addListener('click', placePoint);

            document.getElementById('start').disabled = false;
            document.getElementById('stop').disabled = true;
            document.getElementById('reset').disabled = false; // Keep the Reset button enabled
            document.getElementById('resize').disabled = false; // Enable the Resize button
            document.getElementById('choose-points').disabled = false; // Enable the Choose Points button
            document.getElementById('create-grid').disabled = false; // Enable the Create Grid button
            document.getElementById('solve-tsp').disabled = false; // Enable the Solve TSP button
            document.getElementById('export-points').disabled = false; // Enable the export button
            document.getElementById('export-path').disabled = false; // Enable the export button
            document.getElementById('export-path-gazebo').disabled = false; // Enable the export button
            document.getElementById('own-data').disabled = true; // Disable the own data button


            // Generate the random points
            const numPoints = document.getElementById('num-points').value;
            const bounds = rectangle.getBounds();
            for (let i = 0; i < numPoints; i++) {
                // Generate a random point within the rectangle
                const lat = Math.random() * (bounds.getNorthEast().lat() - bounds.getSouthWest().lat()) + bounds.getSouthWest().lat();
                const lng = Math.random() * (bounds.getNorthEast().lng() - bounds.getSouthWest().lng()) + bounds.getSouthWest().lng();

                // Place the point on the map
                const point = new google.maps.Marker({
                    position: { lat: lat, lng: lng },
                    map: map,
                    label: `${points.length + 1}`,
                    id: points.length + 1
                });

                points.push(point);

                // Update the points display
                document.getElementById('points').innerHTML += 'Point ' + (points.length) + ': ' + point.position.toString() + '<br>';
            }

        }

        function resetDrawing() {
            // Remove the rectangle from the map
            if (rectangle) {
                rectangle.setMap(null);
                rectangle = null;
            }

            // Re-enable the Start button and disable the Stop and Reset buttons
            document.getElementById('start').disabled = false;
            document.getElementById('stop').disabled = true;
            document.getElementById('reset').disabled = true;

            // Clear the coordinate display
            document.getElementById('rectangle-coordinates').innerText = '';
            document.getElementById('resize').disabled = true; // Disable the Resize button

            document.getElementById('choose-points').disabled = true; // Disable the Choose Points button
            document.getElementById('solve-tsp').disabled = false; // Enable the Solve TSP button


            // Remove the points from the map
            for (let i = 0; i < points.length; i++) {
                points[i].setMap(null);
            }

            // Clear the points array and the points display
            points = [];
            document.getElementById('points').innerHTML = '';

            // Stop choosing points
            stopChoosingPoints();

            // Remove the grid lines from the map
            for (let i = 0; i < gridLines.length; i++) {
                gridLines[i].setMap(null);
            }

            // Clear the grid lines array
            gridLines = [];
            // Enable the "Create Grid" button
            document.getElementById('create-grid').disabled = false;

            // Remove each line from the map
            for (let i = 0; i < linePaths.length; i++) {
                linePaths[i].setMap(null);
            }

            linePaths.splice(0, linePaths.length);

        }

        /** Show the new coordinates for the rectangle in an info window. */
        function showNewRect() {

            // Calculate the NE and SW corners
            const ne = rectangle.getBounds().getNorthEast();
            const sw = rectangle.getBounds().getSouthWest();

            // Calculate the NW and SE corners
            const nw = new google.maps.LatLng(ne.lat(), sw.lng());
            const se = new google.maps.LatLng(sw.lat(), ne.lng());

            // Update the coordinate display
            document.getElementById('rectangle-coordinates').innerHTML =
                'NE: ' + ne.toString() + '<br>' +
                'NW: ' + nw.toString() + '<br>' +
                'SW: ' + sw.toString() + '<br>' +
                'SE: ' + se.toString();
        }

        // Calculate the perimeter of the rectangle
        function calculateArea() {

            const ne = rectangle.getBounds().getNorthEast();
            const sw = rectangle.getBounds().getSouthWest();

            const latLength = google.maps.geometry.spherical.computeDistanceBetween(
                new google.maps.LatLng(ne.lat(), sw.lng()),
                new google.maps.LatLng(ne.lat(), ne.lng())
            ); // Length along latitude in meters

            const lngLength = google.maps.geometry.spherical.computeDistanceBetween(
                new google.maps.LatLng(sw.lat(), sw.lng()),
                new google.maps.LatLng(ne.lat(), sw.lng())
            ); // Length along longitude in meters

            const area = latLength * lngLength; // Area in square meters
            const areakm = area / 1000000; // Area in square kilometers

            document.getElementById('rectangle-perimeter').innerHTML = '<p>Area is: <strong>' + area.toLocaleString() + ' meters&sup2;</strong>' + ' | ' + areakm.toLocaleString() + ' km&sup2;</strong></p>';
        }

        // Resize the rectangle to fit the viewport
        function resizeMap() {
            // Get the bounds of the rectangle
            const bounds = rectangle.getBounds();

            // Adjust the map's viewport to fit the rectangle
            map.fitBounds(bounds);
        }

        document.getElementById('solve-tsp').addEventListener('click', function () {

            // Initialize the progress bar
            const progressBar = new ProgressBar.Line('#progress-bar', { color: '#007bff' });
            progressBar.animate(1); // Start the progress bar animation

            // Prepare the data to send to the server
            let locations = points.map(function (point, index) {
                return { id: index + 1, lat: point.getPosition().lat(), lng: point.getPosition().lng() };
            });

            // Specs of the robot based on https://clearpathrobotics.com/warthog-unmanned-ground-vehicle-robot/
            // --- Speed in m/h ---
            const speed = 10000;

            // --- Run time in hours ---
            const runTime = 5;

            // --- Range in km ---
            const range = speed * runTime;

            const capacityInput = document.getElementById('capacity-input');
            const capacity = parseInt(capacityInput.value);

            // Send the locations to the server
            fetch('/solve-tsp/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')  // This gets the CSRF token Django needs
                },
                body: JSON.stringify({ locations: locations, capacity: capacity })
            })
                .then(response => response.json()) // Convert the response to JSON
                .then(data => {
                    // Save the optimal route
                    optimalRoute = data.route;

                    // Create an array of markers in the order of the optimal route
                    let orderedMarkers = optimalRoute.map(routePoint => points.find(point => point.getPosition().lat() === routePoint.lat && point.getPosition().lng() === routePoint.lng));

                    console.log('All markers:', points);
                    console.log('Optimal route:', optimalRoute);
                    console.log('Ordered markers:', orderedMarkers);

                    // ----------------------------------------- UNCOMMENT THIS TO COMPUTE THIS FOR IMPROVED MODEL ----------------------------------------- //
                    // out_of_charge_points is an array of dictionaries
                    data.out_of_charge_points.forEach(point => {
                        const oocpMarker = new google.maps.Marker({
                            position: new google.maps.LatLng(point.lat, point.lng),
                            map: map,
                            title: 'Out of Charge',
                            icon: 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png'
                        });

                        oocMarkers.push(oocpMarker);
                    });

                    // charging_station_location is an array of dictionaries
                    if (data.charging_station_location) {
                        cslMarker = new google.maps.Marker({
                            position: new google.maps.LatLng(data.charging_station_location.lat, data.charging_station_location.lng),
                            map: map,
                            title: 'Charging Station',
                            icon: 'http://maps.google.com/mapfiles/ms/icons/yellow-dot.png'
                        });

                        cslMarker.id = 'ChargingStation'
                        cslMarkers.push(cslMarker);
                    }

                    // ----------- added ---------------- ///////
                    // New code to insert charging station visits
                    pathWithChargingStations = [];
                    let chargeRemaining = capacity;
                    let reserveDistances = [];

                    orderedMarkers.forEach((marker, index) => {
                        // Add the current waypoint to the path
                        pathWithChargingStations.push(marker);

                        // Calculate the distance to the next waypoint, if there is one
                        let distanceToNextWaypoint = index < orderedMarkers.length - 1 ? google.maps.geometry.spherical.computeDistanceBetween(marker.getPosition(), orderedMarkers[index + 1].getPosition()) : 0;

                        // If the robot would run out of charge before reaching the next waypoint, or if the current waypoint is an out-of-charge point, add a visit to the charging station
                        if (chargeRemaining < distanceToNextWaypoint || oocMarkers.some(oocMarker => oocMarker.getPosition().equals(marker.getPosition()))) {

                            // Calculate the distance to the charging station and from the charging station to the next waypoint
                            let distanceToChargingStation = google.maps.geometry.spherical.computeDistanceBetween(marker.getPosition(), cslMarker.getPosition());
                            let distanceFromChargingStationToNextWaypoint = index < orderedMarkers.length - 1 ? google.maps.geometry.spherical.computeDistanceBetween(cslMarker.getPosition(), orderedMarkers[index + 1].getPosition()) : 0;

                            // Calculate the reserve distance
                            let reserveDistance1 = distanceToChargingStation + distanceFromChargingStationToNextWaypoint;

                            // Define the path
                            let path = `Point${marker.id}->ChargingStation->Point${orderedMarkers[index + 1] ? orderedMarkers[index + 1].id : 'end'}`;

                            // Store the reserve distance in the object with the path as the key
                            reserveDistances[path] = reserveDistance1;

                            // Check if it's more efficient to go to the charging station before or after the next waypoint
                            if (chargeRemaining < reserveDistance1) {
                                // Go to the charging station before the next waypoint
                                pathWithChargingStations.push(cslMarker);
                                chargeRemaining = capacity;  // Recharge the robot
                            } else {
                                // Go to the next waypoint before the charging station
                                pathWithChargingStations.push(orderedMarkers[index + 1]);
                                pathWithChargingStations.push(cslMarker);
                                chargeRemaining = capacity - distanceToNextWaypoint;  // Decrease the remaining charge by the distance to the next waypoint
                            }
                        } else {
                            chargeRemaining -= distanceToNextWaypoint;  // Decrease the remaining charge by the distance to the next waypoint
                        }
                    });

                    console.log('Path with charging stations:', pathWithChargingStations)
                    console.log('Reserve distances:', reserveDistances);

                    // If you need the maximum reserve distance, you can still get it as follows:
                    let maxReserveDistance = Math.max(...Object.values(reserveDistances));
                    console.log('Maximum reserve distance:', maxReserveDistance);

                    document.getElementById('max-reserve-distance').innerText = `Max: ${maxReserveDistance} meters`;


                    // Now use pathWithChargingStations instead of orderedMarkers to generate the path
                    pathWithChargingStations.forEach((marker, index) => {
                        if (index < pathWithChargingStations.length - 1) {
                            setTimeout(() => {
                                addLine(map, marker, pathWithChargingStations[index + 1]);
                                progressBar.set(index / (pathWithChargingStations.length - 2)); // Update the progress bar value
                            }, index * 1000); // Xms delay between each line
                        }
                    });

                    let route = pathWithChargingStations.map(marker => marker.id === 'ChargingStation' ? 'Charging Station' : `Point ${marker.id}`);
                    document.getElementById('optimal-route').innerText = route.join('-> ');

                    // -----------------------------------------------------------------------

                    // // ------------------------------ UNCOMMENT THIS TO COMPUTE NORMAL TSP ------------------------------ ///////
                    // //----------------- old code ------------------ ///////
                    // // Iterate over the ordered markers and add each edge to the map with a delay
                    // orderedMarkers.forEach((marker, index) => {
                    //     // Add a line between this marker and the next one
                    //     if (index < orderedMarkers.length - 1) {
                    //         setTimeout(() => {
                    //             addLine(map, marker, orderedMarkers[index + 1]);
                    //         }, index * 250); // 250ms delay between each line
                    //     }
                    // });


                    // // out_of_charge_points is an array of dictionaries
                    // data.out_of_charge_points.forEach(point => {
                    //     const oocpMarker = new google.maps.Marker({
                    //         position: new google.maps.LatLng(point.lat, point.lng),
                    //         map: map,
                    //         title: 'Out of Charge',
                    //         icon: 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png'
                    //     });

                    //     oocMarkers.push(oocpMarker);
                    // });

                    // // charging_station_location is an array of dictionaries
                    // if (data.charging_station_location) {
                    //     cslMarker = new google.maps.Marker({
                    //         position: new google.maps.LatLng(data.charging_station_location.lat, data.charging_station_location.lng),
                    //         map: map,
                    //         title: 'Charging Station',
                    //         icon: 'http://maps.google.com/mapfiles/ms/icons/yellow-dot.png'
                    //     });

                    //     cslMarkers.push(cslMarker);
                    // }

                    // // Create the route array using the returned points
                    // let route = optimalRoute.map(point => `Point ${point.id}`);
                    // document.getElementById('optimal-route').innerText = route.join('-> ');

                    // // ----------------------------------------------------------------------------------

                    // Display the cost of the optimal route
                    document.getElementById('optimal-cost').innerText = `Cost: ${data.cost} meters`;


                    // Calculate the hours, minutes, and seconds
                    // reference: https://stackoverflow.com/questions/19700283/how-to-convert-time-milliseconds-to-hours-min-sec-format-in-javascript

                    const jobdone = data.cost / speed;

                    const hours = Math.floor(jobdone);
                    const minutes = Math.floor((jobdone % 1) * 60);
                    const seconds = Math.floor(((jobdone % 1) * 60 % 1) * 60);

                    // Format the time as hh:mm:ss
                    const formattedTime = `${padZero(hours)}:${padZero(minutes)}:${padZero(seconds)}`;

                    // Display the formatted time
                    document.getElementById('optimal-time').innerText = `Time: ${formattedTime}`;

                    // Function to pad single-digit numbers with a leading zero
                    function padZero(number) {
                        return number.toString().padStart(2, '0');
                    }

                    // Enable the export buttons
                    document.getElementById('export-points').disabled = false;
                    document.getElementById('export-path').disabled = false;

                });

        });

        function exportPoints() {
            let csvContent = "data:text/csv;charset=utf-8,";
            points.forEach(function (point, index) {
                csvContent += `Point ${index + 1},${point.getPosition().lat()},${point.getPosition().lng()}\r\n`;
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "points.csv");
            link.click(); // This will download the data file named "points.csv".
        }

        function exportPath() {
            let csvContent = "data:text/csv;charset=utf-8,";
            let route = pathWithChargingStations;  // Use optimalRoute directly

            route.forEach(function (marker) {
                let position = marker.getPosition();
                let lat = position.lat();
                let lng = position.lng();
                csvContent += `Point ${marker.id},${lat},${lng}\r\n`;
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "path.csv");
            link.click(); // This will download the data file named "path.csv".
        }

        function exportPathGazebo() {
            let csvContent = "data:text/csv;charset=utf-8,";

            // Set the first point as the origin (0, 0, 0)
            let origin = optimalRoute[0];
            csvContent += `Point ${origin.id},0,0,0\r\n`;

            // Convert and export the remaining points
            for (let i = 1; i < optimalRoute.length; i++) {
                let point = optimalRoute[i];
                let dx, dy, dz;

                // Convert latitude and longitude differences to position coordinates (dx, dy) in meters
                let d_lat = point.lat - origin.lat;
                let d_lng = point.lng - origin.lng;

                // Scale the lat and lng differences to desired units (e.g., meters)
                let scalingFactor = 100; // Adjust this scaling factor as needed
                dx = d_lng * scalingFactor;
                dy = d_lat * scalingFactor;

                // Set z-coordinate to a fixed value or compute based on elevation data
                dz = 0;

                csvContent += `Point ${point.id},${dx},${dy},${dz}\r\n`;
            }

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "path.csv");
            link.click(); // This will download the data file named "path.csv".
        }

        // Get the CSRF token Django needs: https://stackoverflow.com/questions/23349883/how-to-pass-csrf-token-to-javascript-file-in-django
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                let cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    let cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        function addLine(map, marker1, marker2) {
            const lineCoordinates = [
                { lat: marker1.getPosition().lat(), lng: marker1.getPosition().lng() },
                { lat: marker2.getPosition().lat(), lng: marker2.getPosition().lng() },
            ];

            const linePath = new google.maps.Polyline({
                path: lineCoordinates,
                geodesic: true,
                strokeColor: "#800080", // purple
                strokeOpacity: 1.0,
                strokeWeight: 4,
            });

            linePath.setMap(map);

            // Store the line path in the linePath array
            linePaths.push(linePath);

        }

        window.initMap = initMap;

    </script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key={{ GOOGLE_MAPS_API_KEY }}&callback=initMap">
    </script>
    </div>
</body>

</html>